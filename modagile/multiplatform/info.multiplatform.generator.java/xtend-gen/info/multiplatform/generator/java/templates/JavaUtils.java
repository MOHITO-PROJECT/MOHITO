/**
 * Copyright (c) 2012-2014 ModAgile Mobile (http://www.modagile-mobile.de/) and others.
 * 
 * Licensed under Eclipse Public License - v 1.0
 * 
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES,
 * INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
 * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
 * SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,
 * WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE
 * USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */
package info.multiplatform.generator.java.templates;

import com.google.common.base.Objects;
import com.google.inject.Inject;
import info.multiplatform.generator.java.helper.Pair;
import info.multiplatform.generator.java.helper.Triple;
import info.multiplatform.generator.java.templates.UtilityFunctions;
import java.util.ArrayList;
import java.util.List;
import java.util.Set;
import java.util.UUID;
import org.eclipse.emf.common.util.EList;
import org.eclipse.emf.ecore.EAttribute;
import org.eclipse.emf.ecore.EClass;
import org.eclipse.emf.ecore.EClassifier;
import org.eclipse.emf.ecore.EPackage;
import org.eclipse.emf.ecore.EReference;
import org.eclipse.emf.ecore.EStructuralFeature;
import org.eclipse.xtend2.lib.StringConcatenation;
import org.eclipse.xtext.xbase.lib.Extension;
import org.eclipse.xtext.xbase.lib.StringExtensions;

@SuppressWarnings("all")
public class JavaUtils {
  @Inject
  @Extension
  private UtilityFunctions utilities;
  
  public String packageNameToFolder(final String packageName) {
    String _replace = packageName.replace(".", "/");
    return (_replace + "/");
  }
  
  public CharSequence statementGenerated(final String templateName) {
    StringConcatenation _builder = new StringConcatenation();
    _builder.append("/* generated by ");
    _builder.append(templateName, "");
    _builder.append(" (xtend) */ ");
    _builder.newLineIfNotEmpty();
    return _builder;
  }
  
  public CharSequence statementGenerated(final Class callingClass) {
    StringConcatenation _builder = new StringConcatenation();
    _builder.append("/* generated by ");
    String _name = callingClass.getName();
    _builder.append(_name, "");
    _builder.append(" (xtend) */ ");
    _builder.newLineIfNotEmpty();
    return _builder;
  }
  
  public CharSequence packageStatement(final String packageName) {
    StringConcatenation _builder = new StringConcatenation();
    {
      boolean _or = false;
      boolean _equals = Objects.equal(packageName, "");
      if (_equals) {
        _or = true;
      } else {
        boolean _equals_1 = Objects.equal(packageName, null);
        _or = (_equals || _equals_1);
      }
      if (_or) {
        _builder.newLine();
      } else {
        _builder.append("package ");
        _builder.append(packageName, "");
        _builder.append(";");
        _builder.newLineIfNotEmpty();
      }
    }
    return _builder;
  }
  
  public CharSequence importStatements(final Set<String> imports) {
    StringConcatenation _builder = new StringConcatenation();
    {
      for(final String importStmt : imports) {
        _builder.append("import ");
        _builder.append(importStmt, "");
        _builder.append(";");
        _builder.newLineIfNotEmpty();
      }
    }
    return _builder;
  }
  
  public CharSequence classDecl(final String className, final String inheritance, final List<String> interfaces, final boolean isAbstract) {
    StringConcatenation _builder = new StringConcatenation();
    _builder.append("public ");
    {
      if (isAbstract) {
        _builder.append(" abstract ");
      }
    }
    _builder.append("class ");
    _builder.append(className, "");
    _builder.newLineIfNotEmpty();
    {
      boolean _and = false;
      boolean _notEquals = (!Objects.equal(inheritance, null));
      if (!_notEquals) {
        _and = false;
      } else {
        boolean _equals = "".equals(inheritance);
        boolean _not = (!_equals);
        _and = (_notEquals && _not);
      }
      if (_and) {
        _builder.append(" ");
        _builder.append("extends ");
        _builder.append(inheritance, " ");
        _builder.newLineIfNotEmpty();
        _builder.append(" ");
      }
    }
    _builder.append(" ");
    {
      boolean _and_1 = false;
      boolean _notEquals_1 = (!Objects.equal(interfaces, null));
      if (!_notEquals_1) {
        _and_1 = false;
      } else {
        boolean _equals_1 = "".equals(interfaces);
        boolean _not_1 = (!_equals_1);
        _and_1 = (_notEquals_1 && _not_1);
      }
      if (_and_1) {
        CharSequence _commaSeparated = this.utilities.commaSeparated("implements ", interfaces);
        _builder.append(_commaSeparated, " ");
      }
    }
    _builder.append(" {");
    _builder.newLineIfNotEmpty();
    _builder.newLine();
    return _builder;
  }
  
  public CharSequence innerClassDecl(final String visibility, final String className, final String inheritance, final List<String> interfaces, final boolean isStatic, final boolean isAbstract) {
    StringConcatenation _builder = new StringConcatenation();
    _builder.append(visibility, "");
    _builder.append(" ");
    {
      if (isAbstract) {
        _builder.append("abstract");
      }
    }
    _builder.append(" ");
    {
      if (isStatic) {
        _builder.append(" static ");
      }
    }
    _builder.append(" class ");
    _builder.append(className, "");
    _builder.newLineIfNotEmpty();
    {
      boolean _and = false;
      boolean _notEquals = (!Objects.equal(inheritance, null));
      if (!_notEquals) {
        _and = false;
      } else {
        boolean _equals = "".equals(inheritance);
        boolean _not = (!_equals);
        _and = (_notEquals && _not);
      }
      if (_and) {
        _builder.append(" ");
        _builder.append("extends ");
        _builder.append(inheritance, " ");
        _builder.newLineIfNotEmpty();
        _builder.append(" ");
      }
    }
    _builder.append(" ");
    {
      boolean _and_1 = false;
      boolean _notEquals_1 = (!Objects.equal(interfaces, null));
      if (!_notEquals_1) {
        _and_1 = false;
      } else {
        boolean _equals_1 = "".equals(interfaces);
        boolean _not_1 = (!_equals_1);
        _and_1 = (_notEquals_1 && _not_1);
      }
      if (_and_1) {
        CharSequence _commaSeparated = this.utilities.commaSeparated("implements ", interfaces);
        _builder.append(_commaSeparated, " ");
      }
    }
    _builder.append(" {");
    _builder.newLineIfNotEmpty();
    _builder.newLine();
    return _builder;
  }
  
  public CharSequence interfaceDecl(final String className, final String inheritanceInterface) {
    StringConcatenation _builder = new StringConcatenation();
    _builder.append("public interface ");
    _builder.append(className, "");
    _builder.append(" ");
    {
      boolean _and = false;
      boolean _notEquals = (!Objects.equal(inheritanceInterface, null));
      if (!_notEquals) {
        _and = false;
      } else {
        boolean _equals = "".equals(inheritanceInterface);
        boolean _not = (!_equals);
        _and = (_notEquals && _not);
      }
      if (_and) {
        _builder.append(" extends ");
        _builder.append(inheritanceInterface, "");
        _builder.newLineIfNotEmpty();
      }
    }
    _builder.append("{");
    _builder.newLine();
    _builder.newLine();
    return _builder;
  }
  
  public CharSequence generateConstructorDecl(final String className, final EList<EAttribute> attributes, final Boolean inherited) {
    StringConcatenation _builder = new StringConcatenation();
    {
      if ((inherited).booleanValue()) {
        _builder.append("public ");
        _builder.append(className, "");
        _builder.append(" (String id) {");
        _builder.newLineIfNotEmpty();
        _builder.append("\t");
        _builder.append("super(id); ");
        _builder.newLine();
        _builder.append("}");
        _builder.newLine();
      }
    }
    _builder.newLine();
    int counter = 0;
    _builder.newLineIfNotEmpty();
    _builder.append("public ");
    _builder.append(className, "");
    _builder.append(" ( String id, ");
    {
      for(final EAttribute att : attributes) {
        String _type = this.getType(att);
        _builder.append(_type, "");
        _builder.append(" ");
        String _name = att.getName();
        _builder.append(_name, "");
        _builder.append(" ");
        _builder.newLineIfNotEmpty();
        {
          int _plus = (counter + 1);
          int _counter = counter = _plus;
          int _size = attributes.size();
          boolean _lessThan = (_counter < _size);
          if (_lessThan) {
            _builder.append(" , ");
            _builder.newLineIfNotEmpty();
          }
        }
      }
    }
    _builder.append(") ");
    _builder.newLineIfNotEmpty();
    int _counter_1 = counter = 0;
    _builder.append(_counter_1, "");
    _builder.newLineIfNotEmpty();
    _builder.append("{");
    _builder.newLine();
    _builder.append("\t");
    _builder.append("super(id, ");
    {
      for(final EAttribute att_1 : attributes) {
        String _type_1 = this.getType(att_1);
        _builder.append(_type_1, "	");
        String _name_1 = att_1.getName();
        _builder.append(_name_1, "	");
        _builder.append(" ");
        _builder.newLineIfNotEmpty();
      }
    }
    {
      for(final EAttribute att_2 : attributes) {
        _builder.append("\t");
        _builder.append("this.");
        String _name_2 = att_2.getName();
        _builder.append(_name_2, "	");
        _builder.append(" = ");
        String _name_3 = att_2.getName();
        _builder.append(_name_3, "	");
        _builder.append(" ");
        _builder.newLineIfNotEmpty();
        _builder.append("\t");
        {
          int _plus_1 = (counter + 1);
          int _counter_2 = counter = _plus_1;
          int _size_1 = attributes.size();
          boolean _lessThan_1 = (_counter_2 < _size_1);
          if (_lessThan_1) {
            _builder.append(" ,");
            _builder.newLineIfNotEmpty();
          }
        }
      }
    }
    _builder.append("}");
    _builder.newLine();
    return _builder;
  }
  
  public CharSequence generateConstructorDecl(final String className, final List<Pair<String,String>> arguments, final CharSequence constrBody) {
    StringConcatenation _builder = new StringConcatenation();
    int counter = 0;
    _builder.newLineIfNotEmpty();
    _builder.append("public ");
    _builder.append(className, "");
    _builder.append("( ");
    _builder.newLineIfNotEmpty();
    {
      boolean _notEquals = (!Objects.equal(arguments, null));
      if (_notEquals) {
        {
          for(final Pair<String,String> pairIter : arguments) {
            _builder.append("\t");
            String _firstElement = pairIter.getFirstElement();
            _builder.append(_firstElement, "	");
            _builder.append(" ");
            String _secondElement = pairIter.getSecondElement();
            _builder.append(_secondElement, "	");
            _builder.newLineIfNotEmpty();
            _builder.append("\t");
            {
              int _plus = (counter + 1);
              int _counter = counter = _plus;
              int _size = arguments.size();
              boolean _lessThan = (_counter < _size);
              if (_lessThan) {
                _builder.append(" ,");
                _builder.newLineIfNotEmpty();
              }
            }
          }
        }
        _builder.append("\t\t\t");
      }
    }
    _builder.append(") {");
    _builder.newLineIfNotEmpty();
    {
      boolean _notEquals_1 = (!Objects.equal(constrBody, null));
      if (_notEquals_1) {
        _builder.append("\t");
        _builder.append(constrBody, "	");
        _builder.newLineIfNotEmpty();
      }
    }
    _builder.append("}");
    _builder.newLine();
    return _builder;
  }
  
  public CharSequence generateNonCompositeBody(final EReference classifier) {
    StringConcatenation _builder = new StringConcatenation();
    _builder.append("private String ");
    EClassifier _eType = classifier.getEType();
    String _name = _eType.getName();
    String _lowerCase = _name.toLowerCase();
    _builder.append(_lowerCase, "");
    _builder.append("UUID;");
    _builder.newLineIfNotEmpty();
    _builder.append("private String ");
    String _name_1 = classifier.getName();
    _builder.append(_name_1, "");
    _builder.append("UUID;");
    _builder.newLineIfNotEmpty();
    _builder.newLine();
    _builder.append("public void set");
    EClassifier _eType_1 = classifier.getEType();
    String _name_2 = _eType_1.getName();
    String _lowerCase_1 = _name_2.toLowerCase();
    String _firstUpper = StringExtensions.toFirstUpper(_lowerCase_1);
    _builder.append(_firstUpper, "");
    _builder.append("UUID(String ");
    EClassifier _eType_2 = classifier.getEType();
    String _name_3 = _eType_2.getName();
    String _lowerCase_2 = _name_3.toLowerCase();
    _builder.append(_lowerCase_2, "");
    _builder.append("UUID) {");
    _builder.newLineIfNotEmpty();
    _builder.append("\t");
    _builder.append("this.");
    EClassifier _eType_3 = classifier.getEType();
    String _name_4 = _eType_3.getName();
    String _lowerCase_3 = _name_4.toLowerCase();
    _builder.append(_lowerCase_3, "	");
    _builder.append("UUID = ");
    EClassifier _eType_4 = classifier.getEType();
    String _name_5 = _eType_4.getName();
    String _lowerCase_4 = _name_5.toLowerCase();
    _builder.append(_lowerCase_4, "	");
    _builder.append("UUID;");
    _builder.newLineIfNotEmpty();
    _builder.append("}");
    _builder.newLine();
    _builder.newLine();
    _builder.append("public String get");
    EClassifier _eType_5 = classifier.getEType();
    String _name_6 = _eType_5.getName();
    String _lowerCase_5 = _name_6.toLowerCase();
    String _firstUpper_1 = StringExtensions.toFirstUpper(_lowerCase_5);
    _builder.append(_firstUpper_1, "");
    _builder.append("UUID() {");
    _builder.newLineIfNotEmpty();
    _builder.append("\t");
    _builder.append("return this.");
    EClassifier _eType_6 = classifier.getEType();
    String _name_7 = _eType_6.getName();
    String _lowerCase_6 = _name_7.toLowerCase();
    _builder.append(_lowerCase_6, "	");
    _builder.append("UUID;");
    _builder.newLineIfNotEmpty();
    _builder.append("}");
    _builder.newLine();
    _builder.newLine();
    _builder.append("public void set");
    String _name_8 = classifier.getName();
    String _firstUpper_2 = StringExtensions.toFirstUpper(_name_8);
    _builder.append(_firstUpper_2, "");
    _builder.append("UUID(String ");
    String _name_9 = classifier.getName();
    _builder.append(_name_9, "");
    _builder.append("UUID) {");
    _builder.newLineIfNotEmpty();
    _builder.append("\t");
    _builder.append("this.");
    String _name_10 = classifier.getName();
    _builder.append(_name_10, "	");
    _builder.append("UUID = ");
    String _name_11 = classifier.getName();
    _builder.append(_name_11, "	");
    _builder.append("UUID;\t\t\t\t");
    _builder.newLineIfNotEmpty();
    _builder.append("}");
    _builder.newLine();
    _builder.newLine();
    _builder.append("public String get");
    String _name_12 = classifier.getName();
    String _firstUpper_3 = StringExtensions.toFirstUpper(_name_12);
    _builder.append(_firstUpper_3, "");
    _builder.append("UUID() {");
    _builder.newLineIfNotEmpty();
    _builder.append("\t");
    _builder.append("return this.");
    String _name_13 = classifier.getName();
    _builder.append(_name_13, "	");
    _builder.append("UUID;");
    _builder.newLineIfNotEmpty();
    _builder.append("}");
    _builder.newLine();
    return _builder;
  }
  
  /**
   * Writes the constants into the stream
   */
  public CharSequence generateCodeForConstants(final List<Triple<String,String,String>> constants) {
    StringConcatenation _builder = new StringConcatenation();
    {
      for(final Triple<String,String,String> constant : constants) {
        {
          String _firstElement = constant.getFirstElement();
          boolean _equals = "int".equals(_firstElement);
          boolean _not = (!_equals);
          if (_not) {
            _builder.append("public static final ");
            String _firstElement_1 = constant.getFirstElement();
            _builder.append(_firstElement_1, "");
            _builder.append(" ");
            String _secondElement = constant.getSecondElement();
            _builder.append(_secondElement, "");
            _builder.append(" ");
            String _xifexpression = null;
            String _thirdElement = constant.getThirdElement();
            boolean _notEquals = (!Objects.equal(_thirdElement, null));
            if (_notEquals) {
              String _thirdElement_1 = constant.getThirdElement();
              String _plus = ("= " + _thirdElement_1);
              _xifexpression = _plus;
            }
            _builder.append(_xifexpression, "");
            _builder.append(";");
            _builder.newLineIfNotEmpty();
          } else {
            _builder.append("public static final ");
            String _firstElement_2 = constant.getFirstElement();
            _builder.append(_firstElement_2, "");
            _builder.append(" ");
            String _secondElement_1 = constant.getSecondElement();
            _builder.append(_secondElement_1, "");
            _builder.append(" ");
            String _xifexpression_1 = null;
            String _thirdElement_2 = constant.getThirdElement();
            boolean _notEquals_1 = (!Objects.equal(_thirdElement_2, null));
            if (_notEquals_1) {
              String _thirdElement_3 = constant.getThirdElement();
              String _plus_1 = ("= " + _thirdElement_3);
              _xifexpression_1 = _plus_1;
            }
            _builder.append(_xifexpression_1, "");
            _builder.append(";");
            _builder.newLineIfNotEmpty();
          }
        }
      }
    }
    return _builder;
  }
  
  public CharSequence generateGetterSetter(final EStructuralFeature att) {
    CharSequence _xifexpression = null;
    int _upperBound = att.getUpperBound();
    int _minus = (-1);
    boolean _equals = (_upperBound == _minus);
    if (_equals) {
      CharSequence _generateGetterSetterToMany = this.generateGetterSetterToMany(att);
      _xifexpression = _generateGetterSetterToMany;
    } else {
      CharSequence _generateGetterSetterToOne = this.generateGetterSetterToOne(att);
      _xifexpression = _generateGetterSetterToOne;
    }
    return _xifexpression;
  }
  
  public CharSequence generateGetterSetterToOne(final EStructuralFeature att) {
    StringConcatenation _builder = new StringConcatenation();
    _builder.append("public ");
    String _type = this.getType(att);
    _builder.append(_type, "");
    _builder.append(" get");
    String _name = att.getName();
    char _charAt = _name.charAt(0);
    String _string = Character.valueOf(_charAt).toString();
    String _upperCase = _string.toUpperCase();
    _builder.append(_upperCase, "");
    String _name_1 = att.getName();
    String _name_2 = att.getName();
    int _length = _name_2.length();
    String _substring = _name_1.substring(1, _length);
    _builder.append(_substring, "");
    _builder.append("() {");
    _builder.newLineIfNotEmpty();
    _builder.append("\t\t\t");
    _builder.append("return ");
    String _name_3 = att.getName();
    _builder.append(_name_3, "			");
    _builder.append(";");
    _builder.newLineIfNotEmpty();
    _builder.append("\t\t");
    _builder.append("}");
    _builder.newLine();
    _builder.append("\t\t\t");
    _builder.newLine();
    _builder.append("\t\t");
    _builder.append("public void set");
    String _name_4 = att.getName();
    char _charAt_1 = _name_4.charAt(0);
    String _string_1 = Character.valueOf(_charAt_1).toString();
    String _upperCase_1 = _string_1.toUpperCase();
    _builder.append(_upperCase_1, "		");
    String _name_5 = att.getName();
    String _name_6 = att.getName();
    int _length_1 = _name_6.length();
    String _substring_1 = _name_5.substring(1, _length_1);
    _builder.append(_substring_1, "		");
    _builder.append("(");
    String _type_1 = this.getType(att);
    _builder.append(_type_1, "		");
    _builder.append(" ");
    String _name_7 = att.getName();
    _builder.append(_name_7, "		");
    _builder.append(") {");
    _builder.newLineIfNotEmpty();
    _builder.append("\t\t\t");
    _builder.append("this.");
    String _name_8 = att.getName();
    _builder.append(_name_8, "			");
    _builder.append(" = ");
    String _name_9 = att.getName();
    _builder.append(_name_9, "			");
    _builder.append(";");
    _builder.newLineIfNotEmpty();
    _builder.append("\t\t");
    _builder.append("}");
    _builder.newLine();
    return _builder;
  }
  
  public CharSequence generateGetterSetterToMany(final EStructuralFeature att) {
    StringConcatenation _builder = new StringConcatenation();
    _builder.append("public List<");
    String _type = this.getType(att);
    _builder.append(_type, "");
    _builder.append("> get");
    String _name = att.getName();
    char _charAt = _name.charAt(0);
    String _string = Character.valueOf(_charAt).toString();
    String _upperCase = _string.toUpperCase();
    _builder.append(_upperCase, "");
    String _name_1 = att.getName();
    String _name_2 = att.getName();
    int _length = _name_2.length();
    String _substring = _name_1.substring(1, _length);
    _builder.append(_substring, "");
    _builder.append("() {");
    _builder.newLineIfNotEmpty();
    _builder.append("\t\t\t");
    _builder.append("return ");
    String _name_3 = att.getName();
    _builder.append(_name_3, "			");
    _builder.append(";");
    _builder.newLineIfNotEmpty();
    _builder.append("\t\t");
    _builder.append("}");
    _builder.newLine();
    _builder.append("\t\t\t");
    _builder.newLine();
    _builder.append("\t\t");
    _builder.append("public void set");
    String _name_4 = att.getName();
    char _charAt_1 = _name_4.charAt(0);
    String _string_1 = Character.valueOf(_charAt_1).toString();
    String _upperCase_1 = _string_1.toUpperCase();
    _builder.append(_upperCase_1, "		");
    String _name_5 = att.getName();
    String _name_6 = att.getName();
    int _length_1 = _name_6.length();
    String _substring_1 = _name_5.substring(1, _length_1);
    _builder.append(_substring_1, "		");
    _builder.append("(List<");
    String _type_1 = this.getType(att);
    _builder.append(_type_1, "		");
    _builder.append("> ");
    String _name_7 = att.getName();
    _builder.append(_name_7, "		");
    _builder.append(") {");
    _builder.newLineIfNotEmpty();
    _builder.append("\t\t\t");
    _builder.append("this.");
    String _name_8 = att.getName();
    _builder.append(_name_8, "			");
    _builder.append(" = ");
    String _name_9 = att.getName();
    _builder.append(_name_9, "			");
    _builder.append(";");
    _builder.newLineIfNotEmpty();
    _builder.append("\t\t");
    _builder.append("}");
    _builder.newLine();
    return _builder;
  }
  
  public CharSequence generateCodeForAttributeOrReference(final EStructuralFeature att) {
    StringConcatenation _builder = new StringConcatenation();
    String _name = att.getName();
    String _plus = ("Entry: generateCodeForAttributeOrReference " + _name);
    System.out.println(_plus);
    _builder.newLineIfNotEmpty();
    {
      int _upperBound = att.getUpperBound();
      int _minus = (-1);
      boolean _equals = (_upperBound == _minus);
      if (_equals) {
        _builder.append("\t\t");
        _builder.append("private List<");
        String _type = this.getType(att);
        _builder.append(_type, "		");
        _builder.append("> ");
        String _name_1 = att.getName();
        _builder.append(_name_1, "		");
        _builder.append(";");
        _builder.newLineIfNotEmpty();
      } else {
        _builder.append("\t\t");
        _builder.append("private ");
        String _type_1 = this.getType(att);
        _builder.append(_type_1, "		");
        _builder.append(" ");
        String _name_2 = att.getName();
        _builder.append(_name_2, "		");
        _builder.append(";");
        _builder.newLineIfNotEmpty();
      }
    }
    return _builder;
  }
  
  public CharSequence generateCodeForAttribute(final String attType, final String attName, final boolean isFinal, final String expr) {
    StringConcatenation _builder = new StringConcatenation();
    String _plus = ("Entry: generateCodeForAttribute " + attName);
    System.out.println(_plus);
    _builder.newLineIfNotEmpty();
    _builder.append("\t\t");
    _builder.append("private ");
    String _xifexpression = null;
    if (isFinal) {
      _xifexpression = "final";
    }
    _builder.append(_xifexpression, "		");
    _builder.append(" ");
    _builder.append(attType, "		");
    _builder.append(" ");
    _builder.append(attName, "		");
    _builder.append(" ");
    String _xifexpression_1 = null;
    boolean _notEquals = (!Objects.equal(expr, null));
    if (_notEquals) {
      String _plus_1 = ("= " + expr);
      _xifexpression_1 = _plus_1;
    }
    _builder.append(_xifexpression_1, "		");
    _builder.append(";");
    _builder.newLineIfNotEmpty();
    return _builder;
  }
  
  public CharSequence generateAdditionalAttributes(final List<Pair<String,String>> pairs) {
    StringConcatenation _builder = new StringConcatenation();
    {
      for(final Pair<String,String> pair : pairs) {
        _builder.append("private ");
        String _firstElement = pair.getFirstElement();
        _builder.append(_firstElement, "");
        _builder.append(" ");
        String _secondElement = pair.getSecondElement();
        _builder.append(_secondElement, "");
        _builder.append(";");
        _builder.newLineIfNotEmpty();
      }
    }
    return _builder;
  }
  
  public CharSequence generateAdditionalAttributes(final List<Pair<String,String>> pairs, final boolean staticQualifier, final boolean finalQualifier) {
    StringConcatenation _builder = new StringConcatenation();
    {
      for(final Pair<String,String> pair : pairs) {
        _builder.append("private ");
        {
          if (staticQualifier) {
            _builder.append(" static ");
          }
        }
        _builder.append(" ");
        {
          if (finalQualifier) {
            _builder.append(" final ");
          }
        }
        _builder.append(" ");
        String _firstElement = pair.getFirstElement();
        _builder.append(_firstElement, "");
        _builder.append(" ");
        String _secondElement = pair.getSecondElement();
        _builder.append(_secondElement, "");
        _builder.append(";");
        _builder.newLineIfNotEmpty();
      }
    }
    return _builder;
  }
  
  public CharSequence generateAdditionalAttribute(final Pair<String,String> pair, final boolean staticQualifier, final boolean finalQualifier) {
    StringConcatenation _builder = new StringConcatenation();
    _builder.append("private ");
    {
      if (staticQualifier) {
        _builder.append(" static ");
      }
    }
    _builder.append(" ");
    {
      if (finalQualifier) {
        _builder.append(" final ");
      }
    }
    _builder.append(" ");
    String _firstElement = pair.getFirstElement();
    _builder.append(_firstElement, "");
    _builder.append(" ");
    String _secondElement = pair.getSecondElement();
    _builder.append(_secondElement, "");
    _builder.append(";");
    _builder.newLineIfNotEmpty();
    return _builder;
  }
  
  public CharSequence generateAdditionalAttributesWithExpression(final Triple<String,String,String> triple, final boolean staticQualifier, final boolean finalQualifier) {
    StringConcatenation _builder = new StringConcatenation();
    _builder.append("private ");
    {
      if (staticQualifier) {
        _builder.append(" static ");
      }
    }
    _builder.append(" ");
    {
      if (finalQualifier) {
        _builder.append(" final ");
      }
    }
    _builder.append(" ");
    String _firstElement = triple.getFirstElement();
    _builder.append(_firstElement, "");
    _builder.append(" ");
    String _secondElement = triple.getSecondElement();
    _builder.append(_secondElement, "");
    _builder.append(" ");
    {
      String _thirdElement = triple.getThirdElement();
      boolean _notEquals = (!Objects.equal(_thirdElement, null));
      if (_notEquals) {
        _builder.append(" = ");
        String _thirdElement_1 = triple.getThirdElement();
        _builder.append(_thirdElement_1, "");
        _builder.append(" ");
      }
    }
    _builder.append(";");
    _builder.newLineIfNotEmpty();
    return _builder;
  }
  
  public String getType(final EStructuralFeature att) {
    String _xifexpression = null;
    if ((att instanceof EAttribute)) {
      EClassifier _eType = att.getEType();
      String _instanceClassName = _eType.getInstanceClassName();
      boolean _equals = _instanceClassName.equals("long");
      if (_equals) {
        return "long";
      } else {
        EClassifier _eType_1 = att.getEType();
        String _instanceClassName_1 = _eType_1.getInstanceClassName();
        boolean _equals_1 = _instanceClassName_1.equals("int");
        if (_equals_1) {
          return "int";
        } else {
          EClassifier _eType_2 = att.getEType();
          String _instanceClassName_2 = _eType_2.getInstanceClassName();
          boolean _equals_2 = _instanceClassName_2.equals("float");
          if (_equals_2) {
            return "float";
          } else {
            EClassifier _eType_3 = att.getEType();
            String _instanceClassName_3 = _eType_3.getInstanceClassName();
            boolean _equals_3 = _instanceClassName_3.equals("double");
            if (_equals_3) {
              return "double";
            } else {
              EClassifier _eType_4 = att.getEType();
              String _instanceClassName_4 = _eType_4.getInstanceClassName();
              boolean _equals_4 = _instanceClassName_4.equals("java.lang.String");
              if (_equals_4) {
                return "String";
              } else {
                EClassifier _eType_5 = att.getEType();
                String _instanceClassName_5 = _eType_5.getInstanceClassName();
                boolean _equals_5 = _instanceClassName_5.equals("boolean");
                if (_equals_5) {
                  return "boolean";
                } else {
                  EClassifier _eType_6 = att.getEType();
                  String _instanceClassName_6 = _eType_6.getInstanceClassName();
                  boolean _equals_6 = _instanceClassName_6.equals("java.util.Date");
                  if (_equals_6) {
                    return "Date";
                  } else {
                    EClassifier _eType_7 = att.getEType();
                    String _instanceClassName_7 = _eType_7.getInstanceClassName();
                    boolean _equals_7 = _instanceClassName_7.equals("byte[]");
                    if (_equals_7) {
                      return "byte[]";
                    } else {
                      EClassifier _eType_8 = att.getEType();
                      return _eType_8.getInstanceClassName();
                    }
                  }
                }
              }
            }
          }
        }
      }
    } else {
      String _xifexpression_1 = null;
      if ((att instanceof EReference)) {
        EClassifier _eType_9 = att.getEType();
        return _eType_9.getName();
      }
      _xifexpression = _xifexpression_1;
    }
    return _xifexpression;
  }
  
  /**
   * Get all classifiers of the supplied domain package.
   * @param EPackage the package to get the classifiers for.
   * @return The list of contained classifiers.
   */
  public List<EClass> getAllDomainEntities(final EPackage domainPackage) {
    ArrayList<EClass> _arrayList = new ArrayList<EClass>();
    List<EClass> domainClasses = _arrayList;
    EList<EClassifier> _eClassifiers = domainPackage.getEClassifiers();
    for (final EClassifier classifier : _eClassifiers) {
      if ((classifier instanceof EClass)) {
        domainClasses.add(((EClass) classifier));
      }
    }
    return domainClasses;
  }
  
  /**
   * returns a list of all references that need to be taken into account when
   * creating mapping classes.
   * Only non-containing references with an upper bound greater the one are returned.
   * TODO Why?
   * 
   * @param domainPackage The package of domain elements to be checked.
   * @return The list of identified references
   */
  public List<EReference> getMappingReferences(final EPackage domainPackage) {
    ArrayList<EReference> _arrayList = new ArrayList<EReference>();
    List<EReference> referenceList = _arrayList;
    EList<EClassifier> _eClassifiers = domainPackage.getEClassifiers();
    for (final EClassifier classifier : _eClassifiers) {
      if ((classifier instanceof EClass)) {
        EClass clazz = ((EClass) classifier);
        EList<EReference> _eAllReferences = clazz.getEAllReferences();
        for (final EReference ref : _eAllReferences) {
          boolean _and = false;
          boolean _isContainment = ref.isContainment();
          boolean _not = (!_isContainment);
          if (!_not) {
            _and = false;
          } else {
            int _upperBound = ref.getUpperBound();
            boolean _greaterThan = (_upperBound > 1);
            _and = (_not && _greaterThan);
          }
          if (_and) {
            boolean _and_1 = false;
            boolean _contains = referenceList.contains(ref);
            boolean _not_1 = (!_contains);
            if (!_not_1) {
              _and_1 = false;
            } else {
              EReference _eOpposite = ref.getEOpposite();
              boolean _contains_1 = referenceList.contains(_eOpposite);
              boolean _not_2 = (!_contains_1);
              _and_1 = (_not_1 && _not_2);
            }
            if (_and_1) {
              referenceList.add(ref);
            }
          }
        }
      }
    }
    return referenceList;
  }
  
  /**
   * Get the list of all domain entity names including
   * data classes and references.
   */
  public List<String> getAllDomainEntityNames(final EPackage domainPackage) {
    ArrayList<String> _arrayList = new ArrayList<String>();
    List<String> domainClassNames = _arrayList;
    List<EClass> _allDomainEntities = this.getAllDomainEntities(domainPackage);
    for (final EClass classifier : _allDomainEntities) {
      String _name = classifier.getName();
      domainClassNames.add(_name);
    }
    List<EReference> _mappingReferences = this.getMappingReferences(domainPackage);
    for (final EReference ref : _mappingReferences) {
      String _name_1 = ref.getName();
      domainClassNames.add(_name_1);
    }
    return domainClassNames;
  }
  
  public CharSequence gernerateSerializeableID(final String packageName, final String projectName, final String entitiyName) {
    StringConcatenation _builder = new StringConcatenation();
    _builder.append("private static final long serialVersionUID = ");
    _builder.newLine();
    String _plus = (packageName + projectName);
    String _plus_1 = (_plus + entitiyName);
    byte[] _bytes = _plus_1.getBytes();
    UUID _nameUUIDFromBytes = UUID.nameUUIDFromBytes(_bytes);
    long _mostSignificantBits = _nameUUIDFromBytes.getMostSignificantBits();
    _builder.append(_mostSignificantBits, "");
    _builder.append("L ;");
    _builder.newLineIfNotEmpty();
    return _builder;
  }
}
